# 前提とゴール

- [12‑Factor Agents（HumanLayer が提示している “生産環境に耐えうる LLM エージェント構築のための12の原則”）](https://github.com/humanlayer/12-factor-agents/tree/main/content)を 体系的に学べる、実際に動作するサンプルコードです。

- このサンプルは「ユーザが自然言語で質問 → エージェントが適切な “ツール呼び出し（関数実行）” を構造化して出力 → 実際にその関数を実行 → 結果を返す」という流れを模します。

- 本番レベルではありませんが、「プロダクション寄りに設計された構造」を意識して作ります。

- 各ファクターのすべてを深く掘るわけではなく、主要なポイントをサンプルコード内に盛り込み、「学び」「動かせるもの」として提示します。

- ご自身の API キー（例えば OpenAI Python を使うなら OPENAI_API_KEY 環境変数など）を使って実験できる構成にします。

# 各ファクターに対応する設計ポイント

以下、12のファクターおよびサンプルコード中で対応・意識したポイントをまとめます。

| ファクター番号                                                    | 名称                                                 | 対応・考慮ポイント                                                     |
| ---------------------------------------------------------- | -------------------------------------------------- | ------------------------------------------------------------- |
| Factor 1：Natural Language to Tool Calls                    | ユーザ入力（自然言語）を、ツール呼び出しの構造化出力に変換                      | `call_llm` 関数が JSON を返し、ツール名＋パラメータ構造を表現                       |
| Factor 2：Own your prompts                                  | プロンプトをブラックボックスにせず、自分で設計・管理                         | `PROMPT_TEMPLATE` を明示、自身でバージョン管理可能な形式に                        |
| Factor 3：Own your context window                           | コンテキスト（履歴）を意図的に制御・管理                               | `ContextManager` によりコンテキストを蓄積・管理（後述）                          |
| Factor 4：Tools are just structured outputs                 | ツールの出力も構造化され、次の処理に明示的に渡せる                          | `tools.py` の関数が dict を返し、JSON構造を前提に操作                         |
| Factor 5：Unify execution state and business state          | 実行の状態（どこまで進んだか）とビジネスの状態を統一的に扱える                    | コンテキストが “ユーザ→決定→ツール呼び出し→結果” を含み、ビジネスステートを明示的に追える              |
| Factor 6：Launch/Pause/Resume with simple APIs              | エージェントの起動・中断・再開を簡単なAPIで扱えるように                      | このサンプルでは簡素化されているが、 `agent_loop` を起点に「セッションID」「途中再開」など拡張可能     |
| Factor 7：Contact humans with tool calls                    | ツール呼び出しとして「人（ヒューマン）を呼ぶ」ことを扱える                      | 例えば “ツール” のひとつとして `request_human_input` を定義することで、人間の介入を構造化できる |
| Factor 8：Own your control flow                             | 制御フロー（ループ、終了条件、分岐等）をエージェント／コードで明示的に持つ              | `while True`＋ `intent == done` というループ構造、自分で制御フローを書いている        |
| Factor 9：Compact Errors into Context Window                | エラーを扱いやすく、コンテキスト内で縮約できるようにする                       | ツール実行時に例外捕捉 → 結果に “error” フィールドを付与し、次のLLM呼び出しのコンテキストに含める設計が可能 |
| Factor 10：Small, Focused Agents                            | エージェントを大きすぎず、フォーカスされたタスクに分割する                      | このサンプルは「ツール呼び出しエージェント」という単一タスクにフォーカス                          |
| Factor 11：Trigger from anywhere, meet users where they are | エージェントを様々なチャネル／トリガーから起動可能にする                       | このサンプルでは CLI 起動を想定しているが、Webhook／チャットボット／API などに拡張できる          |
| Factor 12：Make your agent a stateless reducer              | エージェント自体はステートレスに設計し、各呼び出しが履歴を渡されて出力を返す“リデューサ”として動作 | `agent_loop` は外部から渡された履歴（コンテキスト）を基に動き、内部に長期状態を持たない形に設計可能      |

# 拡張・運用上のヒント

- ContextManager クラスを改良し、「履歴長が長くなったら古いものを削除」「重要な情報だけ残す」といった工夫を入れると “Factor 3” に深く対応できます。

- エラーハンドリング を強化して、ツール呼び出し中に例外が起きたら “error” フィールド付きでコンテキストに残し、LLM に「何が失敗しましたか？次どうしますか？」と聞けるようにすると “Factor 9” に対応。

- 人間介入ツール を用意して、たとえば「この結果で続けていいか人に聞く」などを構造化ツールとして実装すれば “Factor 7” を実践可能。

- API化・Webhook化 すれば “Factor 11” に近づきます。たとえば Flask/FastAPI を使って “/agent” エンドポイントを用意し、チャットサービス・Slack／Teams・メールなどから起動できるように。

- ステートレス化 を進めるには、履歴を DB や外部ストレージに都度保存し、エージェント関数には常に履歴を引数として渡す設計（内部メンバ変数を持たせない）にすると “Factor 12” を体現できます。

- テスト・モニタリング を入れて、どのツールが何回呼ばれたか／LLMの判断がどうだったか をログに記録しておくと、運用に強くなります。
